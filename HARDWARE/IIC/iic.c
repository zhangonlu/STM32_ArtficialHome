#include "iic.h"
#include "delay.h"

/*******************************************************
函数:void IIC_Init(void)
功能:GPIO模拟IIC初始化
参数:无
返回值:无
说明:
	.通过原理图
	I2C_SCL1 --- PB6	---- 默认就是输出
	I2C_SDA1 --- PB7	---- 可能改变有读有写
	.通过芯片手册
	GPIOB ------ AHB1
	发现：SDA又要输入，又要输出，所以我们需要实现宏函数
********************************************************/
void IIC_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;
	/****** 1.使能 GPIOB 时钟总线 ***********/
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	
	/****** 2.初始化 GPIOB相关引脚 **********/
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;			//模式:输出模式
	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;			//类型:推挽 , 他们使用开漏模式方便输出和读取
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;	//引脚:6|7
	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;			//状态:上拉
	
	GPIO_Init(GPIOB, &GPIO_InitStruct);
	/****** 3.设置开始空闲状态电平 **********/
	I2C_SCL = 1;
	I2C_SDA = 1;
}

/*******************************************************
函数:void IIC_Delay(void)
功能:根据需求调整延时函数
说明:
	稳定性还取决于硬件环境和延时函数的精确性。如果您仍然遇
到问题，请确保连接正确，检查延时函数的准确性，并根据具体情况
进行微调。
********************************************************/
void IIC_Delay(void)
{
	delay_us(2);	//根据需要调整延时时间
}

/*******************************************************
函数:void IIC_Start(void)
功能:IIC 起始信号(主控)
参数:无
返回值:无
说明:默认在在高电平期间，数据线由高跳变成低电平，为起始信号
时钟线高电平期间(数据线由高变低的过程)称之为起始信号。
********************************************************/
void IIC_Start(void)
{
	/***** 1.设置为输出模式 ******/
	I2C_OUT();
	
	/***** 2.保持数据线和时钟线高电平 ****/
	I2C_SCL = 1;	// 时钟线保持高电平
	I2C_SDA = 1;	// 数据线保持高电平
	IIC_Delay();	// 持续时间
	
	/***** 3.产生起始信号,将数据拉低   ***/
	I2C_SDA = 0;	// 产生起始信号
	IIC_Delay();	// 持续时间
	
	/***** 4.紧接着拉低时钟线,准备发送数据 ***/
	I2C_SCL = 0;
	IIC_Delay();
}

/*******************************************************
函数:void IIC_Stop(void)
功能:IIC 停止信号(主控)
参数:无
返回值:无
说明:将总线释放,所以为空闲状态,数据线有低电平跳变成高电平,为停止信号
********************************************************/
void IIC_Stop(void)
{
	/***** 1.设置为输出模式 ******/
	I2C_OUT();
	
	/***** 2.产生停止信号 ********/
	I2C_SCL = 1; 	// 拉高时钟线
	I2C_SDA = 0; 	// 产生停止信号
	IIC_Delay();	// 持续时间
	
	/***** 3.变为空闲状态 ********/
	I2C_SDA = 1; // 产生停止信号
	IIC_Delay();	// 持续时间
}


/*******************************************************
函数:void IIC_Ack(void)
功能:IIC 主机产生应答信号(主控)
参数:无
返回值:无
说明:无
********************************************************/
void IIC_Ack(void)
{
	/***** 1.设置为输出模式 ******/
	I2C_OUT();
	
	/***** 2.时钟线高电平，数据线低电平 ****/
	I2C_SDA = 0;	/*------*/
	I2C_SCL = 1;	
	IIC_Delay();	// 持续时间
	
	/***** 3.拉低时钟线,便于下一步操作 ****/
	I2C_SCL = 0;	// 拉低时钟线
	IIC_Delay();
}

/*******************************************************
函数:void IIC_NAck(void)
功能:IIC 主机产生非应答信号(主控)
参数:无
返回值:无
说明:非应答一般不用(×)
********************************************************/
void IIC_NAck(void)
{
	/***** 1.设置为输出模式 ******/
	I2C_OUT();
	
	/***** 2.时钟线高电平，数据线高电平 ****/
	I2C_SDA = 1;	/*------*/
	I2C_SCL = 1;
	IIC_Delay();	// 持续时间
	
	/***** 3.拉低时钟线,便于下一步操作 ****/
	I2C_SCL = 0;	// 拉低时钟线
	IIC_Delay();
}

/*******************************************************
函数:int IIC_Wait_Ack(void)
功能:IIC 主机等待从机应答(从控)
参数:无
返回值:
	应答:0
	非应答:!0
********************************************************/
int IIC_Wait_Ack(void)
{
	/****** 1.将数据线拉高,释放控制权 ****/
	I2C_SDA = 1;
	IIC_Delay();
	
	/****** 2.(从控)设置数据线为输入模式 ****/
	I2C_IN();	//SDA -- PB7 输入模式
	
	/****** 3.拉高时钟线,等待应答信号 *******/
	I2C_SCL = 1;
	IIC_Delay();	// 持续时间
	
	/****** 4.检测数据线是否拉低:应答 *******/
	if(READ_SDA != 0)
	{
		IIC_Stop();	//停止通信
		return 1;	//应答失败(非应答)
	}
	
	I2C_SCL = 0;	//拉低时钟线
	IIC_Delay();
	return 0;		//应答成功(应答)
}

/*******************************************************
函数:void IIC_Send_Byte(u8 data)
功能:IIC 发送1字节 8bit 数据
参数:
	@data:数据
返回值:无
说明:发送数据：高位先出
	数据:0xAA	0101 0100
		 0x80	1000 0000	
		 0		0		0
********************************************************/
void IIC_Send_Byte(u8 data)
{
	/***** 1.设置为输出模式 ******/
	I2C_OUT();
	
	/***** 2.循环发送数据：高位先出 ****/
	for(int i = 0; i < 8;i++)
	{
		/*-------- 准备好数据 ------------------*/
		I2C_SDA = (data & 0x80) >> 7;
		data <<= 1;	//左移1位，准备发送下一位数据
		IIC_Delay();	// 持续时间
		
		/*-------- 拉高时钟线发送数据 ----------*/
		I2C_SCL = 1;
		IIC_Delay();	// 持续时间
		
		/*-------- 拉高时钟线发送数据 ----------*/
		I2C_SCL = 0;
		IIC_Delay();
	}
}

/*******************************************************
函数:u8 IIC_Read_Byte(void)
功能:IIC 接收1字节 8bit 数据
参数:无
返回值:数据
说明:接收数据：高位先入
	0000 0101
				10 1010
********************************************************/
u8 IIC_Read_Byte(void)
{
	u8 data = 0;
	/****** 1.设置为输入模式 *****/
	I2C_IN();
	
	/****** 2.循环读取数据:高位先入 ****/
	for(int i = 0; i < 8;i++)
	{
		data <<= 1;	//先左移
		/****** 拉高时钟线,读取数据线值 ****/
		I2C_SCL = 1;
		IIC_Delay();		// 持续时间
		data |= READ_SDA;	//读取数据
		
		/****** 拉低时钟线,让从设备准备数据 ****/
		I2C_SCL = 0;
		IIC_Delay();
	}
	
	return data;
}

void IIC_Send_Data(u8 Addr,u8 addr,u8 *data,u8 len)
{
	//1.起始信号
	IIC_Start();
	
	//2.从设备地址
	IIC_Send_Byte(Addr | 0x00);
	if(IIC_Wait_Ack() != 0) return ;
	
	//3.操作的地址
	IIC_Send_Byte(addr);
	if(IIC_Wait_Ack() != 0) return ;
	
	//4.循环发送
	for(int i = 0;i < len;i++)
	{
		IIC_Send_Byte(data[i]);
		if(IIC_Wait_Ack() != 0) return ;
	}
	//5.停止信号
	IIC_Stop();
}

void IIC_Read_Data(u8 Addr,u8 addr,u8 *data,u8 len)
{
	//1.起始信号
	IIC_Start();
	
	//2.从设备地址
	IIC_Send_Byte(Addr | 0x00);
	if(IIC_Wait_Ack() != 0) return ;
	
	//3.操作的地址
	IIC_Send_Byte(addr);
	if(IIC_Wait_Ack() != 0) return ;
	
	//4.起始信号
	IIC_Start();
	
	//5.从设备地址
	IIC_Send_Byte(Addr | 0x01);
	if(IIC_Wait_Ack() != 0) return ;
	
	//6.循环读取数据
	for(int i = 0; i < len; i++)
	{
		data[i] = IIC_Read_Byte();
		if(i < len - 1 )IIC_Ack();
	}
	
	//7.停止发送数据
	IIC_NAck();
	IIC_Stop();
}



